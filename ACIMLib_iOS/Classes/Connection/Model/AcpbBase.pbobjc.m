// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: acpb.base.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/ACGPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "ACGPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "AcpbBase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
ACGPBObjCClassDeclaration(ACPBAesKeyAndIVPrivate);
ACGPBObjCClassDeclaration(ACPBConfigItem);
ACGPBObjCClassDeclaration(ACPBUser);

#pragma mark - AcpbBaseRoot

@implementation AcpbBaseRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - AcpbBaseRoot_FileDescriptor

static ACGPBFileDescriptor *AcpbBaseRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static ACGPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    ACGPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[ACGPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:ACGPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ACPBHeartbeatReq

@implementation ACPBHeartbeatReq

@dynamic pingId;
@dynamic disconnectDelay;

typedef struct ACPBHeartbeatReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t pingId;
  int64_t disconnectDelay;
} ACPBHeartbeatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "pingId",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHeartbeatReq_FieldNumber_PingId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBHeartbeatReq__storage_, pingId),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "disconnectDelay",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHeartbeatReq_FieldNumber_DisconnectDelay,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBHeartbeatReq__storage_, disconnectDelay),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBHeartbeatReq class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBHeartbeatReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBHeartbeatResp

@implementation ACPBHeartbeatResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic pingId;

typedef struct ACPBHeartbeatResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
  int64_t pingId;
} ACPBHeartbeatResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHeartbeatResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBHeartbeatResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHeartbeatResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBHeartbeatResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "pingId",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHeartbeatResp_FieldNumber_PingId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBHeartbeatResp__storage_, pingId),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBHeartbeatResp class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBHeartbeatResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\t\000\002\014\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBHandshakeReq

@implementation ACPBHandshakeReq

@dynamic pubKey;
@dynamic timestamp;
@dynamic pubkeyIndex;
@dynamic sign;

typedef struct ACPBHandshakeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t pubkeyIndex;
  NSString *pubKey;
  NSString *sign;
  int64_t timestamp;
} ACPBHandshakeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeReq_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBHandshakeReq__storage_, pubKey),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeReq_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBHandshakeReq__storage_, timestamp),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "pubkeyIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeReq_FieldNumber_PubkeyIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBHandshakeReq__storage_, pubkeyIndex),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "sign",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeReq_FieldNumber_Sign,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBHandshakeReq__storage_, sign),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBHandshakeReq class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBHandshakeReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBHandshakeResp

@implementation ACPBHandshakeResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic pubKey;
@dynamic nonce;
@dynamic sign;

typedef struct ACPBHandshakeResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
  NSString *pubKey;
  NSString *nonce;
  NSString *sign;
} ACPBHandshakeResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBHandshakeResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBHandshakeResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeResp_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBHandshakeResp__storage_, pubKey),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeResp_FieldNumber_Nonce,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBHandshakeResp__storage_, nonce),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBHandshakeResp_FieldNumber_Sign,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACPBHandshakeResp__storage_, sign),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBHandshakeResp class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBHandshakeResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\t\000\002\014\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBConfirmHandshakeReq

@implementation ACPBConfirmHandshakeReq

@dynamic pubKey;
@dynamic timestamp;
@dynamic pubkeyIndex;
@dynamic sign;

typedef struct ACPBConfirmHandshakeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t pubkeyIndex;
  NSString *pubKey;
  NSString *sign;
  int64_t timestamp;
} ACPBConfirmHandshakeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfirmHandshakeReq_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBConfirmHandshakeReq__storage_, pubKey),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfirmHandshakeReq_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBConfirmHandshakeReq__storage_, timestamp),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "pubkeyIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfirmHandshakeReq_FieldNumber_PubkeyIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBConfirmHandshakeReq__storage_, pubkeyIndex),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "sign",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfirmHandshakeReq_FieldNumber_Sign,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBConfirmHandshakeReq__storage_, sign),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBConfirmHandshakeReq class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBConfirmHandshakeReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBConfirmHandshakeResp

@implementation ACPBConfirmHandshakeResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic timestamp;

typedef struct ACPBConfirmHandshakeResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
  int64_t timestamp;
} ACPBConfirmHandshakeResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfirmHandshakeResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBConfirmHandshakeResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfirmHandshakeResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBConfirmHandshakeResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfirmHandshakeResp_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBConfirmHandshakeResp__storage_, timestamp),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBConfirmHandshakeResp class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBConfirmHandshakeResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBAuthSignIn2TokenReq

@implementation ACPBAuthSignIn2TokenReq

@dynamic token;
@dynamic deviceType;
@dynamic imei;
@dynamic brand;
@dynamic model;
@dynamic apnsToken;
@dynamic bandId;
@dynamic sdkVsersion;

typedef struct ACPBAuthSignIn2TokenReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t deviceType;
  NSString *token;
  NSString *imei;
  NSString *brand;
  NSString *model;
  NSString *apnsToken;
  NSString *bandId;
  NSString *sdkVsersion;
} ACPBAuthSignIn2TokenReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, token),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, deviceType),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "imei",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_Imei,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, imei),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "brand",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_Brand,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, brand),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_Model,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, model),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "apnsToken",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_ApnsToken,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, apnsToken),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "bandId",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_BandId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, bandId),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "sdkVsersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenReq_FieldNumber_SdkVsersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenReq__storage_, sdkVsersion),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBAuthSignIn2TokenReq class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBAuthSignIn2TokenReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\n\000\006\t\000\007\006\000\010\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBAuthSignIn2TokenResp

@implementation ACPBAuthSignIn2TokenResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic deviceId;
@dynamic sessionId;
@dynamic noNickName;
@dynamic noEmail;
@dynamic cert;
@dynamic hasBodyAes, bodyAes;
@dynamic userFileDomain;
@dynamic dialogFileDomain;
@dynamic hasUser, user;
@dynamic configItemListArray, configItemListArray_Count;
@dynamic frozenDays;
@dynamic fileDomain;
@dynamic logReportEndpoint;

typedef struct ACPBAuthSignIn2TokenResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  int32_t frozenDays;
  NSString *errorMessage;
  NSString *cert;
  ACPBAesKeyAndIVPrivate *bodyAes;
  NSString *userFileDomain;
  NSString *dialogFileDomain;
  ACPBUser *user;
  NSMutableArray *configItemListArray;
  NSString *fileDomain;
  NSString *logReportEndpoint;
  int64_t deviceId;
  int64_t sessionId;
} ACPBAuthSignIn2TokenResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, deviceId),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_SessionId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, sessionId),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "noNickName",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_NoNickName,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeBool,
      },
      {
        .name = "noEmail",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_NoEmail,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeBool,
      },
      {
        .name = "cert",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_Cert,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, cert),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "bodyAes",
        .dataTypeSpecific.clazz = ACGPBObjCClass(ACPBAesKeyAndIVPrivate),
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_BodyAes,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, bodyAes),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeMessage,
      },
      {
        .name = "userFileDomain",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_UserFileDomain,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, userFileDomain),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "dialogFileDomain",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_DialogFileDomain,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, dialogFileDomain),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.clazz = ACGPBObjCClass(ACPBUser),
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_User,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, user),
        .flags = ACGPBFieldOptional,
        .dataType = ACGPBDataTypeMessage,
      },
      {
        .name = "configItemListArray",
        .dataTypeSpecific.clazz = ACGPBObjCClass(ACPBConfigItem),
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_ConfigItemListArray,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, configItemListArray),
        .flags = (ACGPBFieldFlags)(ACGPBFieldRepeated | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeMessage,
      },
      {
        .name = "frozenDays",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_FrozenDays,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, frozenDays),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "fileDomain",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_FileDomain,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, fileDomain),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "logReportEndpoint",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthSignIn2TokenResp_FieldNumber_LogReportEndpoint,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ACPBAuthSignIn2TokenResp__storage_, logReportEndpoint),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBAuthSignIn2TokenResp class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBAuthSignIn2TokenResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\r\001\t\000\002\014\000\003\010\000\004\t\000\005\n\000\006\007\000\010\007\000\t\016\000\n\020\000\014\000configItem"
        "List\000\r\n\000\016\n\000\017\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBAesKeyAndIVPrivate

@implementation ACPBAesKeyAndIVPrivate

@dynamic aesKey;
@dynamic aesIv;

typedef struct ACPBAesKeyAndIVPrivate__storage_ {
  uint32_t _has_storage_[1];
  NSString *aesKey;
  NSString *aesIv;
} ACPBAesKeyAndIVPrivate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "aesKey",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAesKeyAndIVPrivate_FieldNumber_AesKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBAesKeyAndIVPrivate__storage_, aesKey),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "aesIv",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAesKeyAndIVPrivate_FieldNumber_AesIv,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBAesKeyAndIVPrivate__storage_, aesIv),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBAesKeyAndIVPrivate class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBAesKeyAndIVPrivate__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\004A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBUser

@implementation ACPBUser

@dynamic uid;
@dynamic nickName;
@dynamic langCode;
@dynamic phone;
@dynamic numberInPhoneBook;
@dynamic smallAvatarURL;
@dynamic originalAvatarURL;
@dynamic email;
@dynamic qrcodeString;
@dynamic gender;
@dynamic contactStatus;
@dynamic alias;
@dynamic aliasMobileArray, aliasMobileArray_Count;
@dynamic aliasDesp;
@dynamic dialogMenuContent;
@dynamic chatRobotType;

typedef struct ACPBUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t gender;
  int32_t contactStatus;
  int32_t chatRobotType;
  NSString *nickName;
  NSString *langCode;
  NSString *phone;
  NSString *numberInPhoneBook;
  NSString *smallAvatarURL;
  NSString *originalAvatarURL;
  NSString *email;
  NSString *qrcodeString;
  NSString *alias;
  NSMutableArray *aliasMobileArray;
  NSString *aliasDesp;
  NSString *dialogMenuContent;
  int64_t uid;
} ACPBUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, uid),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, nickName),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "langCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_LangCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, langCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_Phone,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, phone),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "numberInPhoneBook",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_NumberInPhoneBook,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, numberInPhoneBook),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "smallAvatarURL",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_SmallAvatarURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, smallAvatarURL),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "originalAvatarURL",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_OriginalAvatarURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, originalAvatarURL),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_Email,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, email),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "qrcodeString",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_QrcodeString,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, qrcodeString),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "gender",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_Gender,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, gender),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "contactStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_ContactStatus,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, contactStatus),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "alias",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_Alias,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, alias),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "aliasMobileArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_AliasMobileArray,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, aliasMobileArray),
        .flags = (ACGPBFieldFlags)(ACGPBFieldRepeated | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "aliasDesp",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_AliasDesp,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, aliasDesp),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "dialogMenuContent",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_DialogMenuContent,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, dialogMenuContent),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "chatRobotType",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUser_FieldNumber_ChatRobotType,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ACPBUser__storage_, chatRobotType),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUser class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUser__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\002\010\000\003\010\000\005\021\000\006\014!!\000\007\017!!\000\t\014\000\013\r\000\r\000aliasMobile\000"
        "\016\t\000\017\021\000\020\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBConfigItem

@implementation ACPBConfigItem

@dynamic key;
@dynamic value;

typedef struct ACPBConfigItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} ACPBConfigItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfigItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBConfigItem__storage_, key),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBConfigItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBConfigItem__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBConfigItem class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBConfigItem__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBAuthLogOutReq

@implementation ACPBAuthLogOutReq

@dynamic appVersionCode;
@dynamic deviceType;
@dynamic imei;
@dynamic brand;
@dynamic model;

typedef struct ACPBAuthLogOutReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t appVersionCode;
  int32_t deviceType;
  NSString *imei;
  NSString *brand;
  NSString *model;
} ACPBAuthLogOutReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "appVersionCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthLogOutReq_FieldNumber_AppVersionCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBAuthLogOutReq__storage_, appVersionCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthLogOutReq_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBAuthLogOutReq__storage_, deviceType),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "imei",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthLogOutReq_FieldNumber_Imei,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBAuthLogOutReq__storage_, imei),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "brand",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthLogOutReq_FieldNumber_Brand,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBAuthLogOutReq__storage_, brand),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthLogOutReq_FieldNumber_Model,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACPBAuthLogOutReq__storage_, model),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBAuthLogOutReq class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBAuthLogOutReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\016\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBAuthLogOutResp

@implementation ACPBAuthLogOutResp

@dynamic errorCode;
@dynamic errorMessage;

typedef struct ACPBAuthLogOutResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
} ACPBAuthLogOutResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthLogOutResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBAuthLogOutResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBAuthLogOutResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBAuthLogOutResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBAuthLogOutResp class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBAuthLogOutResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBUpdateApnsTokenReq

@implementation ACPBUpdateApnsTokenReq

@dynamic apnsToken;
@dynamic brand;
@dynamic pushKitToken;

typedef struct ACPBUpdateApnsTokenReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *apnsToken;
  NSString *brand;
  NSString *pushKitToken;
} ACPBUpdateApnsTokenReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "apnsToken",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateApnsTokenReq_FieldNumber_ApnsToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBUpdateApnsTokenReq__storage_, apnsToken),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "brand",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateApnsTokenReq_FieldNumber_Brand,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBUpdateApnsTokenReq__storage_, brand),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "pushKitToken",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateApnsTokenReq_FieldNumber_PushKitToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBUpdateApnsTokenReq__storage_, pushKitToken),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUpdateApnsTokenReq class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUpdateApnsTokenReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBUpdateApnsTokenResp

@implementation ACPBUpdateApnsTokenResp

@dynamic errorCode;
@dynamic errorMessage;

typedef struct ACPBUpdateApnsTokenResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
} ACPBUpdateApnsTokenResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateApnsTokenResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBUpdateApnsTokenResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateApnsTokenResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBUpdateApnsTokenResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUpdateApnsTokenResp class]
                                     rootClass:[AcpbBaseRoot class]
                                          file:AcpbBaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUpdateApnsTokenResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
