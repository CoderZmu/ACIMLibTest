// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/protobuf/wrappers.proto

#import "ACGPBProtocolBuffers_RuntimeSupport.h"
#import "ACGPBWrappers.pbobjc.h"

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ACGPBWrappersRoot

@implementation ACGPBWrappersRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ACGPBWrappersRoot_FileDescriptor

static ACGPBFileDescriptor *ACGPBWrappersRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static ACGPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    ACGPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[ACGPBFileDescriptor alloc] initWithPackage:@"google.protobuf"
                                                 objcPrefix:@"ACGPB"
                                                     syntax:ACGPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ACGPBDoubleValue

@implementation ACGPBDoubleValue

@dynamic value;

typedef struct ACGPBDoubleValue__storage_ {
  uint32_t _has_storage_[1];
  double value;
} ACGPBDoubleValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBDoubleValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBDoubleValue__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeDouble,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBDoubleValue class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBDoubleValue__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBFloatValue

@implementation ACGPBFloatValue

@dynamic value;

typedef struct ACGPBFloatValue__storage_ {
  uint32_t _has_storage_[1];
  float value;
} ACGPBFloatValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBFloatValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBFloatValue__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeFloat,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBFloatValue class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBFloatValue__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBInt64Value

@implementation ACGPBInt64Value

@dynamic value;

typedef struct ACGPBInt64Value__storage_ {
  uint32_t _has_storage_[1];
  int64_t value;
} ACGPBInt64Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBInt64Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBInt64Value__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBInt64Value class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBInt64Value__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBUInt64Value

@implementation ACGPBUInt64Value

@dynamic value;

typedef struct ACGPBUInt64Value__storage_ {
  uint32_t _has_storage_[1];
  uint64_t value;
} ACGPBUInt64Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBUInt64Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBUInt64Value__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeUInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBUInt64Value class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBUInt64Value__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBInt32Value

@implementation ACGPBInt32Value

@dynamic value;

typedef struct ACGPBInt32Value__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
} ACGPBInt32Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBInt32Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBInt32Value__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBInt32Value class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBInt32Value__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBUInt32Value

@implementation ACGPBUInt32Value

@dynamic value;

typedef struct ACGPBUInt32Value__storage_ {
  uint32_t _has_storage_[1];
  uint32_t value;
} ACGPBUInt32Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBUInt32Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBUInt32Value__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeUInt32,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBUInt32Value class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBUInt32Value__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBBoolValue

@implementation ACGPBBoolValue

@dynamic value;

typedef struct ACGPBBoolValue__storage_ {
  uint32_t _has_storage_[1];
} ACGPBBoolValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBBoolValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeBool,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBBoolValue class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBBoolValue__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBStringValue

@implementation ACGPBStringValue

@dynamic value;

typedef struct ACGPBStringValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
} ACGPBStringValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBStringValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBStringValue__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBStringValue class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBStringValue__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACGPBBytesValue

@implementation ACGPBBytesValue

@dynamic value;

typedef struct ACGPBBytesValue__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} ACGPBBytesValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACGPBBytesValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACGPBBytesValue__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeBytes,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACGPBBytesValue class]
                                     rootClass:[ACGPBWrappersRoot class]
                                          file:ACGPBWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACGPBBytesValue__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
