// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: acpb.user.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/ACGPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "ACGPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "AcpbUser.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
ACGPBObjCClassDeclaration(ACPBSysConfigItem);

#pragma mark - AcpbUserRoot

@implementation AcpbUserRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - AcpbUserRoot_FileDescriptor

static ACGPBFileDescriptor *AcpbUserRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static ACGPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    ACGPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[ACGPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:ACGPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ACPBUserFrozenToLoginResp

@implementation ACPBUserFrozenToLoginResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic frozenType;
@dynamic forceLogoutDeleteAllLocalMessagesFlag;

typedef struct ACPBUserFrozenToLoginResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  int32_t frozenType;
  NSString *errorMessage;
} ACPBUserFrozenToLoginResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUserFrozenToLoginResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBUserFrozenToLoginResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUserFrozenToLoginResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBUserFrozenToLoginResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "frozenType",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUserFrozenToLoginResp_FieldNumber_FrozenType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBUserFrozenToLoginResp__storage_, frozenType),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "forceLogoutDeleteAllLocalMessagesFlag",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUserFrozenToLoginResp_FieldNumber_ForceLogoutDeleteAllLocalMessagesFlag,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeBool,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUserFrozenToLoginResp class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUserFrozenToLoginResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\014\000\003\n\000\004\037\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetUserOnlineTimeReq

@implementation ACPBGetUserOnlineTimeReq

@dynamic destId;

typedef struct ACPBGetUserOnlineTimeReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t destId;
} ACPBGetUserOnlineTimeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "destId",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetUserOnlineTimeReq_FieldNumber_DestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBGetUserOnlineTimeReq__storage_, destId),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetUserOnlineTimeReq class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetUserOnlineTimeReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetUserOnlineTimeResp

@implementation ACPBGetUserOnlineTimeResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic onlinestatus;
@dynamic lastOnlineTime;

typedef struct ACPBGetUserOnlineTimeResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  int32_t onlinestatus;
  NSString *errorMessage;
  int64_t lastOnlineTime;
} ACPBGetUserOnlineTimeResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetUserOnlineTimeResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBGetUserOnlineTimeResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetUserOnlineTimeResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBGetUserOnlineTimeResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "onlinestatus",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetUserOnlineTimeResp_FieldNumber_Onlinestatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBGetUserOnlineTimeResp__storage_, onlinestatus),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "lastOnlineTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetUserOnlineTimeResp_FieldNumber_LastOnlineTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACPBGetUserOnlineTimeResp__storage_, lastOnlineTime),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetUserOnlineTimeResp class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetUserOnlineTimeResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\t\000\002\014\000\004\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBUpdatePushConfigReq

@implementation ACPBUpdatePushConfigReq

@dynamic content;

typedef struct ACPBUpdatePushConfigReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} ACPBUpdatePushConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdatePushConfigReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBUpdatePushConfigReq__storage_, content),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUpdatePushConfigReq class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUpdatePushConfigReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBUpdatePushConfigResp

@implementation ACPBUpdatePushConfigResp

@dynamic errorCode;
@dynamic errorMessage;

typedef struct ACPBUpdatePushConfigResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
} ACPBUpdatePushConfigResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdatePushConfigResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBUpdatePushConfigResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdatePushConfigResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBUpdatePushConfigResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUpdatePushConfigResp class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUpdatePushConfigResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetPushConfigResp

@implementation ACPBGetPushConfigResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic content;

typedef struct ACPBGetPushConfigResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
  NSString *content;
} ACPBGetPushConfigResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetPushConfigResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBGetPushConfigResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetPushConfigResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBGetPushConfigResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetPushConfigResp_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACPBGetPushConfigResp__storage_, content),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetPushConfigResp class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetPushConfigResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBUpdateBlockContactsReq

@implementation ACPBUpdateBlockContactsReq

@dynamic destIdsArray, destIdsArray_Count;
@dynamic blockFlag;

typedef struct ACPBUpdateBlockContactsReq__storage_ {
  uint32_t _has_storage_[1];
  ACGPBInt64Array *destIdsArray;
} ACPBUpdateBlockContactsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "destIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateBlockContactsReq_FieldNumber_DestIdsArray,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBUpdateBlockContactsReq__storage_, destIdsArray),
        .flags = (ACGPBFieldFlags)(ACGPBFieldRepeated | ACGPBFieldPacked | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "blockFlag",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateBlockContactsReq_FieldNumber_BlockFlag,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeBool,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUpdateBlockContactsReq class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUpdateBlockContactsReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000destIds\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBUpdateBlockContactsResp

@implementation ACPBUpdateBlockContactsResp

@dynamic errorCode;
@dynamic errorMessage;

typedef struct ACPBUpdateBlockContactsResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
} ACPBUpdateBlockContactsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateBlockContactsResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBUpdateBlockContactsResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBUpdateBlockContactsResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBUpdateBlockContactsResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBUpdateBlockContactsResp class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBUpdateBlockContactsResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetBlocksReq

@implementation ACPBGetBlocksReq

@dynamic destIdArray, destIdArray_Count;

typedef struct ACPBGetBlocksReq__storage_ {
  uint32_t _has_storage_[1];
  ACGPBInt64Array *destIdArray;
} ACPBGetBlocksReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "destIdArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetBlocksReq_FieldNumber_DestIdArray,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetBlocksReq__storage_, destIdArray),
        .flags = (ACGPBFieldFlags)(ACGPBFieldRepeated | ACGPBFieldPacked | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetBlocksReq class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetBlocksReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000destId\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetBlocksResp

@implementation ACPBGetBlocksResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic destIdsArray, destIdsArray_Count;

typedef struct ACPBGetBlocksResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
  ACGPBInt64Array *destIdsArray;
} ACPBGetBlocksResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetBlocksResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBGetBlocksResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetBlocksResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBGetBlocksResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "destIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetBlocksResp_FieldNumber_DestIdsArray,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetBlocksResp__storage_, destIdsArray),
        .flags = (ACGPBFieldFlags)(ACGPBFieldRepeated | ACGPBFieldPacked | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetBlocksResp class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetBlocksResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\t\000\002\014\000\003\000destIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetSysConfigReq

@implementation ACPBGetSysConfigReq


typedef struct ACPBGetSysConfigReq__storage_ {
  uint32_t _has_storage_[1];
} ACPBGetSysConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetSysConfigReq class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ACPBGetSysConfigReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetSysConfigResp

@implementation ACPBGetSysConfigResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic configArray, configArray_Count;

typedef struct ACPBGetSysConfigResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
  NSMutableArray *configArray;
} ACPBGetSysConfigResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSysConfigResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBGetSysConfigResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSysConfigResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBGetSysConfigResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "configArray",
        .dataTypeSpecific.clazz = ACGPBObjCClass(ACPBSysConfigItem),
        .number = ACPBGetSysConfigResp_FieldNumber_ConfigArray,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetSysConfigResp__storage_, configArray),
        .flags = ACGPBFieldRepeated,
        .dataType = ACGPBDataTypeMessage,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetSysConfigResp class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetSysConfigResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBSysConfigItem

@implementation ACPBSysConfigItem

@dynamic key;
@dynamic value;

typedef struct ACPBSysConfigItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} ACPBSysConfigItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBSysConfigItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBSysConfigItem__storage_, key),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBSysConfigItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBSysConfigItem__storage_, value),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBSysConfigItem class]
                                     rootClass:[AcpbUserRoot class]
                                          file:AcpbUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBSysConfigItem__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
