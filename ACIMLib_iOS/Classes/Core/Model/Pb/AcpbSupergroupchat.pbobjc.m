// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: acpb.supergroupchat.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if ACGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/ACGPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "ACGPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "AcpbSupergroupchat.pbobjc.h"
#import "AcpbPrivatechat.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
ACGPBObjCClassDeclaration(ACPBDialogMessageList);
ACGPBObjCClassDeclaration(ACPBGetSuperGroupNewMessageReq);
ACGPBObjCClassDeclaration(ACPBGetSuperGroupNewMessageResp);

#pragma mark - AcpbSupergroupchatRoot

@implementation AcpbSupergroupchatRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - AcpbSupergroupchatRoot_FileDescriptor

static ACGPBFileDescriptor *AcpbSupergroupchatRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static ACGPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    ACGPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[ACGPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:ACGPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ACPBSendSuperGroupMessageResp

@implementation ACPBSendSuperGroupMessageResp

@dynamic dialogKey;
@dynamic hasMsg, msg;

typedef struct ACPBSendSuperGroupMessageResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *dialogKey;
  ACPBDialogMessageList *msg;
} ACPBSendSuperGroupMessageResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "dialogKey",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBSendSuperGroupMessageResp_FieldNumber_DialogKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBSendSuperGroupMessageResp__storage_, dialogKey),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = ACGPBObjCClass(ACPBDialogMessageList),
        .number = ACPBSendSuperGroupMessageResp_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBSendSuperGroupMessageResp__storage_, msg),
        .flags = ACGPBFieldOptional,
        .dataType = ACGPBDataTypeMessage,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBSendSuperGroupMessageResp class]
                                     rootClass:[AcpbSupergroupchatRoot class]
                                          file:AcpbSupergroupchatRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBSendSuperGroupMessageResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetSuperGroupNewMessageReq

@implementation ACPBGetSuperGroupNewMessageReq

@dynamic dialogKeys, dialogKeys_Count;
@dynamic offset;
@dynamic readOffsets, readOffsets_Count;

typedef struct ACPBGetSuperGroupNewMessageReq__storage_ {
  uint32_t _has_storage_[1];
  ACGPBStringInt64Dictionary *dialogKeys;
  ACGPBStringInt64Dictionary *readOffsets;
  int64_t offset;
} ACPBGetSuperGroupNewMessageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "dialogKeys",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageReq_FieldNumber_DialogKeys,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageReq__storage_, dialogKeys),
        .flags = (ACGPBFieldFlags)(ACGPBFieldMapKeyString | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageReq_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageReq__storage_, offset),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
      {
        .name = "readOffsets",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageReq_FieldNumber_ReadOffsets,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageReq__storage_, readOffsets),
        .flags = (ACGPBFieldFlags)(ACGPBFieldMapKeyString | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetSuperGroupNewMessageReq class]
                                     rootClass:[AcpbSupergroupchatRoot class]
                                          file:AcpbSupergroupchatRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetSuperGroupNewMessageReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBGetSuperGroupNewMessageResp

@implementation ACPBGetSuperGroupNewMessageResp

@dynamic errorCode;
@dynamic errorMessage;
@dynamic msg, msg_Count;
@dynamic msgEnd, msgEnd_Count;
@dynamic unreadCounts, unreadCounts_Count;
@dynamic readOffsets, readOffsets_Count;

typedef struct ACPBGetSuperGroupNewMessageResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
  NSMutableDictionary *msg;
  ACGPBStringBoolDictionary *msgEnd;
  ACGPBStringInt32Dictionary *unreadCounts;
  ACGPBStringInt64Dictionary *readOffsets;
} ACPBGetSuperGroupNewMessageResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = ACGPBObjCClass(ACPBDialogMessageList),
        .number = ACPBGetSuperGroupNewMessageResp_FieldNumber_Msg,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageResp__storage_, msg),
        .flags = ACGPBFieldMapKeyString,
        .dataType = ACGPBDataTypeMessage,
      },
      {
        .name = "msgEnd",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageResp_FieldNumber_MsgEnd,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageResp__storage_, msgEnd),
        .flags = (ACGPBFieldFlags)(ACGPBFieldMapKeyString | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeBool,
      },
      {
        .name = "unreadCounts",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageResp_FieldNumber_UnreadCounts,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageResp__storage_, unreadCounts),
        .flags = (ACGPBFieldFlags)(ACGPBFieldMapKeyString | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "readOffsets",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBGetSuperGroupNewMessageResp_FieldNumber_ReadOffsets,
        .hasIndex = ACGPBNoHasBit,
        .offset = (uint32_t)offsetof(ACPBGetSuperGroupNewMessageResp__storage_, readOffsets),
        .flags = (ACGPBFieldFlags)(ACGPBFieldMapKeyString | ACGPBFieldTextFormatNameCustom),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBGetSuperGroupNewMessageResp class]
                                     rootClass:[AcpbSupergroupchatRoot class]
                                          file:AcpbSupergroupchatRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBGetSuperGroupNewMessageResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\t\000\002\014\000\004\006\000\005\014\000\006\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBClearSuperGroupUnreadStatusReq

@implementation ACPBClearSuperGroupUnreadStatusReq

@dynamic dialogId;
@dynamic readOffset;

typedef struct ACPBClearSuperGroupUnreadStatusReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *dialogId;
  int64_t readOffset;
} ACPBClearSuperGroupUnreadStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "dialogId",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBClearSuperGroupUnreadStatusReq_FieldNumber_DialogId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBClearSuperGroupUnreadStatusReq__storage_, dialogId),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
      {
        .name = "readOffset",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBClearSuperGroupUnreadStatusReq_FieldNumber_ReadOffset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBClearSuperGroupUnreadStatusReq__storage_, readOffset),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt64,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBClearSuperGroupUnreadStatusReq class]
                                     rootClass:[AcpbSupergroupchatRoot class]
                                          file:AcpbSupergroupchatRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBClearSuperGroupUnreadStatusReq__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACPBClearSuperGroupUnreadStatusResp

@implementation ACPBClearSuperGroupUnreadStatusResp

@dynamic errorCode;
@dynamic errorMessage;

typedef struct ACPBClearSuperGroupUnreadStatusResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
} ACPBClearSuperGroupUnreadStatusResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (ACGPBDescriptor *)descriptor {
  static ACGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static ACGPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBClearSuperGroupUnreadStatusResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACPBClearSuperGroupUnreadStatusResp__storage_, errorCode),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = ACPBClearSuperGroupUnreadStatusResp_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACPBClearSuperGroupUnreadStatusResp__storage_, errorMessage),
        .flags = (ACGPBFieldFlags)(ACGPBFieldOptional | ACGPBFieldTextFormatNameCustom | ACGPBFieldClearHasIvarOnZero),
        .dataType = ACGPBDataTypeString,
      },
    };
    ACGPBDescriptor *localDescriptor =
        [ACGPBDescriptor allocDescriptorForClass:[ACPBClearSuperGroupUnreadStatusResp class]
                                     rootClass:[AcpbSupergroupchatRoot class]
                                          file:AcpbSupergroupchatRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(ACGPBMessageFieldDescription))
                                   storageSize:sizeof(ACPBClearSuperGroupUnreadStatusResp__storage_)
                                         flags:(ACGPBDescriptorInitializationFlags)(ACGPBDescriptorInitializationFlag_UsesClassRefs | ACGPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !ACGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
